{
    "ACQUIRE_CCD":                              { "Direction": "DEVICE_TO_HOST", "Opcode": "0xAD", "Type": "Uint16[]","ReadEndpoint": 2, "ReadBlockSize": 2048, "BatchTest": false },
    "GET_ACTUAL_FRAMES":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xE4", "Type": "Uint16",  "Length": 2 },
    "GET_ACTUAL_INTEGRATION_TIME":              { "Direction": "DEVICE_TO_HOST", "Opcode": "0xDF", "Type": "Uint32",  "Length": 6, "Units": "ms", "Notes": "Response of 0xffffff indicates error" },
    "GET_CCD_GAIN":                             { "Direction": "DEVICE_TO_HOST", "Opcode": "0xC5", "Type": "Float16", "Length": 2, "Notes": "Returns odd 16-bit half-precision float, where MSB is integral part and LSB is fractional" },
    "GET_CCD_OFFSET":                           { "Direction": "DEVICE_TO_HOST", "Opcode": "0xC4", "Type": "Uint16",  "Length": 2 },
    "GET_CCD_SENSING_THRESHOLD":                { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD1", "Type": "Uint16",  "Length": 2 },
    "GET_CCD_TEMP":                             { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD7", "Type": "Uint16",  "Length": 2, "Reverse": true, "Notes": "Raw 12-bit ADC output from the TEC; big-endian (MSB-LSB), unlike most other commands" },
    "GET_CCD_TEMP_ENABLE":                      { "Direction": "DEVICE_TO_HOST", "Opcode": "0xDA", "Type": "Bool",    "Length": 1 }, 
    "GET_CCD_TEMP_SETPOINT":                    { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD9", "Type": "Uint16",  "Length": 2,  "wIndex": 0, "Notes": "Set wIndex to 1 for reading DAC (external laser power), 0 for reading raw CCD temperature" },
    "GET_CCD_THRESHOLD_SENSING_MODE":           { "Direction": "DEVICE_TO_HOST", "Opcode": "0xCF", "Type": "Bool",    "Length": 1 },
    "GET_CCD_TRIGGER_SOURCE":                   { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD3", "Type": "Enum",    "Length": 1, "Enum": [ "USB", "EXTERNAL" ] },
    "GET_CF_SELECT":                            { "Direction": "DEVICE_TO_HOST", "Opcode": "0xEC", "Type": "Bool",    "Length": 1, "Supports": [ "InGaAs" ], "Notes": "AKA, getHighGainModeEnabled" },
    "GET_CODE_REVISION":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xC0", "Type": "Byte[]",  "Length": 4, "Reverse": true, "Notes": "Bytes are read-out backwards ([0xaa bb cc dd] means version dd.cc.bb.aa)" },
    "GET_DAC":                                  { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD9", "Type": "Uint16",  "Length": 2,  "wIndex": 1, "Notes": "Set wIndex to 1 for reading DAC (external laser power), 0 for reading raw CCD temperature" },
    "GET_EXTERNAL_TRIGGER_OUTPUT":              { "Direction": "DEVICE_TO_HOST", "Opcode": "0xE1", "Type": "Enum",    "Length": 1, "Enum": [ "LASER_MODULATION", "INTEGRATION_ACTIVE_PULSE" ] },
    "GET_FPGA_REV":                             { "Direction": "DEVICE_TO_HOST", "Opcode": "0xB4", "Type": "String",  "Length": 7 },
    "GET_HORIZ_BINNING":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xBC", "Type": "Enum",    "Length": 1, "Enum": [ "NONE", "TWO_PIXEL", "FOUR_PIXEL" ], "Supports": [ "ARM" ] },
    "GET_INTEGRATION_TIME":                     { "Direction": "DEVICE_TO_HOST", "Opcode": "0xBF", "Type": "Uint32",  "Length": 3, "ReadBack": 6, "Units": "ms" },
    "GET_INTERLOCK":                            { "Direction": "DEVICE_TO_HOST", "Opcode": "0xEF", "Type": "Bool",    "Length": 1, "Supports": [ "FX2" ], "Notes": "Couldn't get to work on ARM, checking with Jason" },
    "GET_LASER_ENABLED":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xE2", "Type": "Bool",    "Length": 1 },
    "GET_LASER_MOD_DURATION":                   { "Direction": "DEVICE_TO_HOST", "Opcode": "0xC3", "Type": "Uint40",  "Length": 5 },
    "GET_LASER_MOD_ENABLED":                    { "Direction": "DEVICE_TO_HOST", "Opcode": "0xE3", "Type": "Bool",    "Length": 1 },
    "GET_LASER_MOD_PULSE_WIDTH":                { "Direction": "DEVICE_TO_HOST", "Opcode": "0xDC", "Type": "Uint40",  "Length": 5 },
    "GET_LASER_RAMPING_MODE":                   { "Direction": "DEVICE_TO_HOST", "Opcode": "0xEA", "Type": "Bool",    "Length": 1, "Supports": [ "ARM" ] },
    "GET_LASER_TEMP":                           { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD5", "Type": "Uint16",  "Length": 2, "BatchTestARM": false, "Notes": "causes problems on ARM if no laser connected?" },
    "GET_LASER_TEMP_SETPOINT":                  { "Direction": "DEVICE_TO_HOST", "Opcode": "0xE8", "Type": "Uint16",  "Length": 1, "BatchTestARM": false, "Supports": [ "ARM" ], "Notes": "TODO: Unclear what this returns; documented length of 1 byte is insufficient for 12-bit DAC? Also, didn't work in testing (may fail if no laser?)." },
    "GET_LINE_LENGTH":                          { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Uint16",  "Length": 2, "wValue": "0x03", "Notes": "causes problems on ARM in combination with others?" },
    "GET_LINK_LASER_MOD_TO_INTEGRATION_TIME":   { "Direction": "DEVICE_TO_HOST", "Opcode": "0xDE", "Type": "Bool",    "Length": 1 }, 
    "GET_MODEL_CONFIG":                         { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Byte[]",  "Length": 64, "wValue": "0x01", "Uses": [ "wIndex" ], "Notes": "Pass desired page index (0-7) via wIndex" },
    "GET_MOD_PERIOD":                           { "Direction": "DEVICE_TO_HOST", "Opcode": "0xCB", "Type": "Uint40",  "Length": 5 },
    "GET_MOD_PULSE_DELAY":                      { "Direction": "DEVICE_TO_HOST", "Opcode": "0xCA", "Type": "Uint40",  "Length": 5 },
    "GET_SELECTED_LASER":                       { "Direction": "DEVICE_TO_HOST", "Opcode": "0xEE", "Type": "Uint8",   "Length": 1 },
    "GET_TRIGGER_DELAY":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xAB", "Type": "Uint32",  "Length": 3, "Supports": [ "ARM" ], "Units": "0.5 us", "Notes": "Delay is in 0.5us, supports 24-bit unsigned value (about 8.3sec)" },
    "LINK_LASER_MOD_TO_INTEGRATION_TIME":       { "Direction": "HOST_TO_DEVICE", "Opcode": "0xDD", "Type": "Bool",    "ARMInvertedReturn": true },
    "OPT_ACT_INT_TIME":                         { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Bool",    "Length": 1, "wValue": "0x0B", "FakeBufferLength": 8 },
    "OPT_AREA_SCAN":                            { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Bool",    "Length": 1, "wValue": "0x00", "FakeBufferLength": 8 },
    "OPT_AREA_SCAN":                            { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Bool",    "Length": 1, "wValue": "0x0A", "FakeBufferLength": 8 },
    "OPT_CF_SELECT":                            { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Bool",    "Length": 1, "wValue": "0x07", "FakeBufferLength": 8 },
    "OPT_DATA_HDR_TAB":                         { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Enum",    "Length": 1, "wValue": "0x06", "Enum": [ "NONE", "OCEAN_OPTICS", "WASATCH" ] },
    "OPT_HORIZONTAL_BINNING":                   { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Bool",    "Length": 1, "wValue": "0x0C", "Notes": "Not sure how this is used" },
    "OPT_INT_TIME_RES":                         { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Enum",    "Length": 1, "wValue": "0x05", "Enum": [ "ONE_MS", "TEN_MS", "SWITCHABLE" ] },
    "OPT_LASER":                                { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Enum",    "Length": 1, "wValue": "0x08", "Enum": [ "NONE", "INTERNAL", "EXTERNAL" ] },
    "OPT_LASER_CONTROL":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Enum",    "Length": 1, "wValue": "0x09", "Enum": [ "MODULATION", "TRANSITION_POINTS", "RAMPING" ] },
    "POLL_DATA":                                { "Direction": "DEVICE_TO_HOST", "Opcode": "0xD4", "Type": "Uint32",  "Length": 4 },
    "READ_COMPILATION_OPTIONS":                 { "Direction": "DEVICE_TO_HOST", "Opcode": "0xFF", "Type": "Uint16",  "Length": 2, "wValue": "0x04", "FakeBufferLength": 8 },
    "SELECT_HORIZ_BINNING":                     { "Direction": "HOST_TO_DEVICE", "Opcode": "0xB8", "Type": "Enum",    "Supports": [ "ARM" ], "Enum": ["NONE", "TWO_PIXEL", "FOUR_PIXEL" ] },
    "SELECT_LASER":                             { "Direction": "HOST_TO_DEVICE", "Opcode": "0xED", "Type": "Uint16",  "ARMInvertedReturn": true, "Enabled": false },
    "SET_CCD_GAIN":                             { "Direction": "HOST_TO_DEVICE", "Opcode": "0xB7", "Type": "Float16", "ARMInvertedReturn": true, "Notes": "Takes an odd 16-bit half-precision float where MSB is the integral part and LSB is fractional part" },
    "SET_CCD_OFFSET":                           { "Direction": "HOST_TO_DEVICE", "Opcode": "0xB6", "Type": "Uint16",  "ARMInvertedReturn": true },
    "SET_CCD_SENSING_THRESHOLD":                { "Direction": "HOST_TO_DEVICE", "Opcode": "0xD0", "Type": "Uint16",  "ARMInvertedReturn": true },
    "SET_CCD_TEC_ENABLE":                       { "Direction": "HOST_TO_DEVICE", "Opcode": "0xD6", "Type": "Bool",    "ARMInvertedReturn": true },
    "SET_CCD_TEMP_SETPOINT":                    { "Direction": "HOST_TO_DEVICE", "Opcode": "0xD8", "Type": "Uint12",  "ARMInvertedReturn": true, "Notes": "Send raw 12-bit DAC value to TEC; normally computed from user input in DegC, converted to raw using degCToDACCoeffs from EEPROM; degC should not exceed min/max values from EEPROM." },
    "SET_CCD_THRESHOLD_SENSING_MODE":           { "Direction": "HOST_TO_DEVICE", "Opcode": "0xCE", "Type": "Bool",    "ARMInvertedReturn": true },
    "SET_CCD_TRIGGER_SOURCE":                   { "Direction": "HOST_TO_DEVICE", "Opcode": "0xD2", "Type": "Bool",    "ARMInvertedReturn": true },
    "SET_CF_SELECT":                            { "Direction": "HOST_TO_DEVICE", "Opcode": "0xEB", "Type": "Bool",    "Supports": [ "InGaAs" ], "Notes": "Used to enable high gain mode on NIR" },
    "SET_DAC":                                  { "Direction": "HOST_TO_DEVICE", "Opcode": "0xD8", "Type": "Uint16",  "wIndex": 1, "ARMInvertedReturn": true, "Notes": "Used to set external laser power" },
    "SET_DFU_MODE":                             { "Direction": "HOST_TO_DEVICE", "Opcode": "0xFE", "Type": "Bool",    "Supports": [ "ARM" ], "BatchTest": false, "Notes": "Used to prepare STM32 ARM to accept firmware update via DfuSe Demonstrator (en.stsw-stm32080); takes no arguments" },
    "SET_EXTERNAL_TRIGGER_OUTPUT":              { "Direction": "HOST_TO_DEVICE", "Opcode": "0xE0", "Type": "Bool",    "ARMInvertedReturn": true },
    "SET_INTEGRATION_TIME":                     { "Direction": "HOST_TO_DEVICE", "Opcode": "0xB2", "Type": "Uint32",  "Units" : "ms", "Uses" : [ "wValue", "wIndex" ], "ARMInvertedReturn": true, "Notes": "Integration time in ms or 10ms (see OPT_INT_TIME_RES) sent as 32-bit word: LSW as wValue, MSW as wIndex" },
    "SET_LASER_ENABLED":                        { "Direction": "HOST_TO_DEVICE", "Opcode": "0xBE", "Type": "Bool",    "ARMInvertedReturn": true, "BatchTest": false },
    "SET_LASER_MOD_DURATION":                   { "Direction": "HOST_TO_DEVICE", "Opcode": "0xB9", "Type": "Uint40",  "ARMInvertedReturn": true },
    "SET_LASER_MOD_ENABLED":                    { "Direction": "HOST_TO_DEVICE", "Opcode": "0xBD", "Type": "Bool",    "FakeBufferLength": 8, "ARMInvertedReturn": true, "Notes": "MZ: Can we deprecate FakeBufferLength?" },
    "SET_LASER_MOD_PULSE_WIDTH":                { "Direction": "HOST_TO_DEVICE", "Opcode": "0xDB", "Type": "Uint40",  "ARMInvertedReturn": true, "MakeFakeBufferFromValue": true, "Notes": "API Kludge: sending integral width as length of fake buffer" },
    "SET_LASER_RAMPING_MODE":                   { "Direction": "HOST_TO_DEVICE", "Opcode": "0xE9", "Type": "Bool",    "Supports": [ "ARM" ] },
    "SET_LASER_TEMP_SETPOINT":                  { "Direction": "HOST_TO_DEVICE", "Opcode": "0xE7", "Type": "Uint12",  "ARMInvertedReturn": true, "Notes": "Probably unimplemented in firmware?" },
    "SET_MODEL_CONFIG_DO_NOT_USE":              { "Direction": "HOST_TO_DEVICE", "Opcode": "0xFF", "Type": "Byte[]",  "wValue": "0x02", "Enabled": false },
    "SET_MODEL_CONFIG_REAL":                    { "Direction": "HOST_TO_DEVICE", "Opcode": "0xA2", "Type": "Byte[]",  "Length": 64, "BatchTest": false, "Notes": "wValue should be 0x3c00 + 64 * (zero-indexed page index); buf should be 64 bytes" },
    "SET_MOD_PERIOD":                           { "Direction": "HOST_TO_DEVICE", "Opcode": "0xC7", "Type": "Uint40",  "ARMInvertedReturn": true, "MakeFakeBufferFromValue": true, "Notes": "API Kludge: sending integral percentage as length of fake buffer" },
    "SET_MOD_PULSE_DELAY":                      { "Direction": "HOST_TO_DEVICE", "Opcode": "0xC6", "Type": "Uint40",  "ARMInvertedReturn": true },
    "SET_TRIGGER_DELAY":                        { "Direction": "HOST_TO_DEVICE", "Opcode": "0xAA", "Type": "Uint24",  "Units": "0.5 us", "Supports": [ "ARM" ], "Notes": "Delay is in 0.5us (range is about 8.3sec)" },
    "VR_GET_CONTINUOUS_CCD":                    { "Direction": "DEVICE_TO_HOST", "Opcode": "0xCC", "Type": "Bool",    "Length": 1 },
    "VR_GET_NUM_FRAMES":                        { "Direction": "DEVICE_TO_HOST", "Opcode": "0xCD", "Type": "Uint8",   "Length": 1 },
    "VR_SET_CONTINUOUS_CCD":                    { "Direction": "HOST_TO_DEVICE", "Opcode": "0xC8", "Type": "Bool",    "ARMInvertedReturn": true, "Notes": "When using external triggering, perform multiple acquisitions on a single inbound trigger event." },
    "VR_SET_NUM_FRAMES":                        { "Direction": "HOST_TO_DEVICE", "Opcode": "0xC9", "Type": "Uint8",   "ARMInvertedReturn": true, "Notes": "When using continuous CCD acquisitions with external triggering, how many spectra are being acquired per trigger event." }
}
